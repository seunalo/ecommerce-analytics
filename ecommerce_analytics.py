# -*- coding: utf-8 -*-
"""ecommerce_analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LzrfE8pusz0ErV6E4Xr2ULkRrDrd0ghx

# E-commerce Sales Analytics & Customer Segmentation

**Date:** December 2018  
**Dataset:** UCI Online Retail Dataset

---

## Project Overview

This project analyzes transactional data from a UK-based online retail company to:

1. **Explore sales trends** and identify seasonal patterns
2. **Segment customers** using RFM (Recency, Frequency, Monetary) analysis
3. **Build a demand forecasting model** for inventory optimization
4. **Generate actionable business insights** for marketing and operations

### Business Questions Addressed:
- What are the peak sales periods and best-selling products?
- Who are our most valuable customers?
- How can we predict future demand to optimize inventory?
- Which customer segments should marketing prioritize?

---

## 1. Setup & Data Loading
"""

# Import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import warnings
warnings.filterwarnings('ignore')

# Set display options
pd.set_option('display.max_columns', None)
pd.set_option('display.float_format', lambda x: '%.2f' % x)

# Set style for visualizations
plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette('husl')

print('Libraries loaded successfully!')

# Load the UCI Online Retail dataset
# Dataset source: https://archive.ics.uci.edu/ml/datasets/online+retail

url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/00352/Online%20Retail.xlsx'

# Load data
print('Loading dataset... (this may take a moment)')
df = pd.read_excel(url)
print(f'Dataset loaded: {df.shape[0]:,} rows, {df.shape[1]} columns')

# First look at the data
print('=== Dataset Info ===')
print(f'Shape: {df.shape}')
print(f'\nColumn Types:')
print(df.dtypes)
print(f'\nFirst 5 rows:')
df.head()

# Check for missing values
print('=== Missing Values ===')
missing = df.isnull().sum()
missing_pct = (missing / len(df) * 100).round(2)
missing_df = pd.DataFrame({'Missing Count': missing, 'Percentage': missing_pct})
print(missing_df[missing_df['Missing Count'] > 0])

"""## 2. Data Cleaning & Preprocessing"""

# Create a copy for cleaning
data = df.copy()

# Remove rows with missing CustomerID (can't do customer analysis without it)
print(f'Rows before cleaning: {len(data):,}')
data = data.dropna(subset=['CustomerID'])
print(f'Rows after removing missing CustomerID: {len(data):,}')

# Remove cancelled orders (InvoiceNo starting with 'C')
data = data[~data['InvoiceNo'].astype(str).str.startswith('C')]
print(f'Rows after removing cancellations: {len(data):,}')

# Remove negative quantities and prices
data = data[(data['Quantity'] > 0) & (data['UnitPrice'] > 0)]
print(f'Rows after removing invalid quantities/prices: {len(data):,}')

# Convert CustomerID to integer
data['CustomerID'] = data['CustomerID'].astype(int)

# Create Revenue column
data['Revenue'] = data['Quantity'] * data['UnitPrice']

# Extract date features
data['InvoiceDate'] = pd.to_datetime(data['InvoiceDate'])
data['Date'] = data['InvoiceDate'].dt.date
data['Year'] = data['InvoiceDate'].dt.year
data['Month'] = data['InvoiceDate'].dt.month
data['DayOfWeek'] = data['InvoiceDate'].dt.dayofweek
data['Hour'] = data['InvoiceDate'].dt.hour

print(f'\nFinal cleaned dataset: {len(data):,} rows')
data.head()

# Summary statistics
print('=== Summary Statistics ===')
print(f"Date Range: {data['InvoiceDate'].min()} to {data['InvoiceDate'].max()}")
print(f"Total Transactions: {data['InvoiceNo'].nunique():,}")
print(f"Total Customers: {data['CustomerID'].nunique():,}")
print(f"Total Products: {data['StockCode'].nunique():,}")
print(f"Total Revenue: ${data['Revenue'].sum():,.2f}")
print(f"Countries: {data['Country'].nunique()}")

"""## 3. Exploratory Data Analysis (EDA)

### 3.1 Revenue Analysis
"""

# Monthly Revenue Trend
monthly_revenue = data.groupby([data['InvoiceDate'].dt.to_period('M')])['Revenue'].sum()

fig, ax = plt.subplots(figsize=(12, 5))
monthly_revenue.plot(kind='line', marker='o', ax=ax, linewidth=2, markersize=6)
ax.set_title('Monthly Revenue Trend', fontsize=14, fontweight='bold')
ax.set_xlabel('Month')
ax.set_ylabel('Revenue ($)')
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('monthly_revenue_trend.png', dpi=150, bbox_inches='tight')
plt.show()

print('\n=== Key Insight ===')
print(f"Peak revenue month: {monthly_revenue.idxmax()} (${monthly_revenue.max():,.2f})")
print(f"Average monthly revenue: ${monthly_revenue.mean():,.2f}")

# Revenue by Day of Week
day_names = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
daily_revenue = data.groupby('DayOfWeek')['Revenue'].sum()

# Reindex daily_revenue to include all days of the week (0-6) and fill missing with 0
daily_revenue = daily_revenue.reindex(range(7), fill_value=0)

fig, ax = plt.subplots(figsize=(10, 5))
bars = ax.bar(day_names, daily_revenue.values, color=sns.color_palette('husl', 7))
ax.set_title('Revenue by Day of Week', fontsize=14, fontweight='bold')
ax.set_xlabel('Day of Week')
ax.set_ylabel('Total Revenue ($)')
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

# Add value labels
for bar, val in zip(bars, daily_revenue.values):
    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 5000,
            f'${val/1000:.0f}K', ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.savefig('revenue_by_day.png', dpi=150, bbox_inches='tight')
plt.show()

print('\n=== Key Insight ===')
print(f"Highest revenue day: {day_names[daily_revenue.idxmax()]}")
print(f"Note: Saturday shows significantly lower sales - potential for weekend promotions")

# Revenue by Hour
hourly_revenue = data.groupby('Hour')['Revenue'].sum()

fig, ax = plt.subplots(figsize=(12, 5))
ax.fill_between(hourly_revenue.index, hourly_revenue.values, alpha=0.3)
ax.plot(hourly_revenue.index, hourly_revenue.values, linewidth=2, marker='o')
ax.set_title('Revenue by Hour of Day', fontsize=14, fontweight='bold')
ax.set_xlabel('Hour of Day')
ax.set_ylabel('Total Revenue ($)')
ax.set_xticks(range(6, 21))
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))
plt.tight_layout()
plt.savefig('revenue_by_hour.png', dpi=150, bbox_inches='tight')
plt.show()

print('\n=== Key Insight ===')
print(f"Peak shopping hours: 10 AM - 3 PM")
print(f"Recommendation: Schedule marketing emails and promotions for morning hours")

"""### 3.2 Product Analysis"""

# Top 10 Products by Revenue
product_revenue = data.groupby(['StockCode', 'Description'])['Revenue'].sum().sort_values(ascending=False)
top_10_products = product_revenue.head(10).reset_index()

fig, ax = plt.subplots(figsize=(12, 6))
bars = ax.barh(range(10), top_10_products['Revenue'].values, color=sns.color_palette('viridis', 10))
ax.set_yticks(range(10))
ax.set_yticklabels([desc[:40] + '...' if len(str(desc)) > 40 else desc
                    for desc in top_10_products['Description']], fontsize=9)
ax.set_title('Top 10 Products by Revenue', fontsize=14, fontweight='bold')
ax.set_xlabel('Revenue ($)')
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))
ax.invert_yaxis()
plt.tight_layout()
plt.savefig('top_10_products.png', dpi=150, bbox_inches='tight')
plt.show()

print('\n=== Top 5 Products ===')
for i, row in top_10_products.head(5).iterrows():
    print(f"{i+1}. {row['Description'][:50]}: ${row['Revenue']:,.2f}")

# Top 10 Countries by Revenue (excluding UK)
country_revenue = data.groupby('Country')['Revenue'].sum().sort_values(ascending=False)

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# All countries
top_countries = country_revenue.head(10)
axes[0].pie(top_countries.values, labels=top_countries.index, autopct='%1.1f%%', startangle=90)
axes[0].set_title('Revenue Distribution by Country (Top 10)', fontweight='bold')

# Excluding UK
non_uk = country_revenue[country_revenue.index != 'United Kingdom'].head(10)
axes[1].barh(range(len(non_uk)), non_uk.values, color=sns.color_palette('coolwarm', len(non_uk)))
axes[1].set_yticks(range(len(non_uk)))
axes[1].set_yticklabels(non_uk.index)
axes[1].set_title('Top 10 Countries (Excluding UK)', fontweight='bold')
axes[1].set_xlabel('Revenue ($)')
axes[1].xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))
axes[1].invert_yaxis()

plt.tight_layout()
plt.savefig('revenue_by_country.png', dpi=150, bbox_inches='tight')
plt.show()

uk_pct = (country_revenue['United Kingdom'] / country_revenue.sum() * 100)
print(f'\n=== Key Insight ===')
print(f'UK accounts for {uk_pct:.1f}% of revenue')
print(f'Top international markets: {list(non_uk.head(3).index)}')

"""## 4. Customer Segmentation (RFM Analysis)"""

# Calculate RFM metrics
# Reference date = day after last transaction
reference_date = data['InvoiceDate'].max() + timedelta(days=1)

rfm = data.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (reference_date - x.max()).days,  # Recency
    'InvoiceNo': 'nunique',  # Frequency
    'Revenue': 'sum'  # Monetary
}).reset_index()

rfm.columns = ['CustomerID', 'Recency', 'Frequency', 'Monetary']

print('=== RFM Summary Statistics ===')
print(rfm[['Recency', 'Frequency', 'Monetary']].describe().round(2))
rfm.head(10)

# RFM Score Calculation (1-5 scale)
# Recency: lower is better (more recent)
rfm['R_Score'] = pd.qcut(rfm['Recency'], q=5, labels=[5, 4, 3, 2, 1])

# Frequency: higher is better
rfm['F_Score'] = pd.qcut(rfm['Frequency'].rank(method='first'), q=5, labels=[1, 2, 3, 4, 5])

# Monetary: higher is better
rfm['M_Score'] = pd.qcut(rfm['Monetary'], q=5, labels=[1, 2, 3, 4, 5])

# Combined RFM Score
rfm['RFM_Score'] = rfm['R_Score'].astype(str) + rfm['F_Score'].astype(str) + rfm['M_Score'].astype(str)
rfm['RFM_Total'] = rfm['R_Score'].astype(int) + rfm['F_Score'].astype(int) + rfm['M_Score'].astype(int)

rfm.head(10)

# Customer Segmentation based on RFM
def segment_customer(row):
    r, f, m = int(row['R_Score']), int(row['F_Score']), int(row['M_Score'])

    if r >= 4 and f >= 4 and m >= 4:
        return 'Champions'
    elif r >= 3 and f >= 3 and m >= 3:
        return 'Loyal Customers'
    elif r >= 4 and f <= 2:
        return 'New Customers'
    elif r >= 3 and f >= 3 and m <= 2:
        return 'Potential Loyalists'
    elif r <= 2 and f >= 3 and m >= 3:
        return 'At Risk'
    elif r <= 2 and f <= 2 and m >= 3:
        return 'Cant Lose Them'
    elif r <= 2 and f <= 2 and m <= 2:
        return 'Lost'
    else:
        return 'Others'

rfm['Segment'] = rfm.apply(segment_customer, axis=1)

# Segment summary
segment_summary = rfm.groupby('Segment').agg({
    'CustomerID': 'count',
    'Recency': 'mean',
    'Frequency': 'mean',
    'Monetary': ['mean', 'sum']
}).round(2)

segment_summary.columns = ['Count', 'Avg_Recency', 'Avg_Frequency', 'Avg_Monetary', 'Total_Revenue']
segment_summary['Pct_Customers'] = (segment_summary['Count'] / segment_summary['Count'].sum() * 100).round(1)
segment_summary['Pct_Revenue'] = (segment_summary['Total_Revenue'] / segment_summary['Total_Revenue'].sum() * 100).round(1)
segment_summary = segment_summary.sort_values('Total_Revenue', ascending=False)

print('=== Customer Segments ===')
segment_summary

# Visualize Customer Segments
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Segment by Customer Count
segment_counts = rfm['Segment'].value_counts()
colors = sns.color_palette('Set2', len(segment_counts))
axes[0].pie(segment_counts.values, labels=segment_counts.index, autopct='%1.1f%%',
            colors=colors, startangle=90)
axes[0].set_title('Customer Distribution by Segment', fontsize=12, fontweight='bold')

# Segment by Revenue
segment_revenue = rfm.groupby('Segment')['Monetary'].sum().sort_values(ascending=True)
axes[1].barh(segment_revenue.index, segment_revenue.values, color=sns.color_palette('viridis', len(segment_revenue)))
axes[1].set_title('Revenue by Customer Segment', fontsize=12, fontweight='bold')
axes[1].set_xlabel('Total Revenue ($)')
axes[1].xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

plt.tight_layout()
plt.savefig('customer_segments.png', dpi=150, bbox_inches='tight')
plt.show()

print('\n=== Key Insights ===')
champions = segment_summary.loc['Champions'] if 'Champions' in segment_summary.index else None
if champions is not None:
    print(f"Champions: {champions['Pct_Customers']:.1f}% of customers, {champions['Pct_Revenue']:.1f}% of revenue")
print(f"\nAction Items:")
print("- Champions: Reward program, early access to new products")
print("- At Risk: Re-engagement campaign, special offers")
print("- New Customers: Onboarding emails, first-purchase discount for next order")

# RFM Heatmap
rfm_heatmap = rfm.groupby(['R_Score', 'F_Score']).size().unstack(fill_value=0)

fig, ax = plt.subplots(figsize=(10, 8))
sns.heatmap(rfm_heatmap, annot=True, fmt='d', cmap='YlGnBu', ax=ax)
ax.set_title('Customer Count by Recency & Frequency Scores', fontsize=14, fontweight='bold')
ax.set_xlabel('Frequency Score (1=Low, 5=High)')
ax.set_ylabel('Recency Score (1=Long Ago, 5=Recent)')
plt.tight_layout()
plt.savefig('rfm_heatmap.png', dpi=150, bbox_inches='tight')
plt.show()

"""## 5. K-Means Clustering for Customer Segmentation"""

# Prepare data for clustering
rfm_clustering = rfm[['Recency', 'Frequency', 'Monetary']].copy()

# Log transform to handle skewness
rfm_clustering['Recency_log'] = np.log1p(rfm_clustering['Recency'])
rfm_clustering['Frequency_log'] = np.log1p(rfm_clustering['Frequency'])
rfm_clustering['Monetary_log'] = np.log1p(rfm_clustering['Monetary'])

# Standardize
scaler = StandardScaler()
rfm_scaled = scaler.fit_transform(rfm_clustering[['Recency_log', 'Frequency_log', 'Monetary_log']])

# Find optimal K using Elbow Method
inertias = []
K_range = range(2, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(rfm_scaled)
    inertias.append(kmeans.inertia_)

# Plot Elbow Curve
fig, ax = plt.subplots(figsize=(10, 5))
ax.plot(K_range, inertias, marker='o', linewidth=2, markersize=8)
ax.set_title('Elbow Method for Optimal K', fontsize=14, fontweight='bold')
ax.set_xlabel('Number of Clusters (K)')
ax.set_ylabel('Inertia')
ax.axvline(x=4, color='r', linestyle='--', label='Optimal K=4')
ax.legend()
plt.tight_layout()
plt.savefig('elbow_curve.png', dpi=150, bbox_inches='tight')
plt.show()

# Apply K-Means with K=4
kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)
rfm['Cluster'] = kmeans.fit_predict(rfm_scaled)

# Cluster summary
cluster_summary = rfm.groupby('Cluster').agg({
    'CustomerID': 'count',
    'Recency': 'mean',
    'Frequency': 'mean',
    'Monetary': ['mean', 'sum']
}).round(2)

cluster_summary.columns = ['Count', 'Avg_Recency', 'Avg_Frequency', 'Avg_Monetary', 'Total_Revenue']

# Name clusters based on characteristics
cluster_names = {
    cluster_summary['Avg_Monetary'].idxmax(): 'High Value',
    cluster_summary['Avg_Recency'].idxmax(): 'Churned',
    cluster_summary['Avg_Frequency'].idxmax(): 'Frequent Buyers',
}
# Assign remaining cluster
for i in range(4):
    if i not in cluster_names:
        cluster_names[i] = 'Regular'
        break

rfm['Cluster_Name'] = rfm['Cluster'].map(cluster_names)

print('=== K-Means Cluster Summary ===')
cluster_summary

# Visualize Clusters
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Scatter plot: Frequency vs Monetary
scatter = axes[0].scatter(rfm['Frequency'], rfm['Monetary'], c=rfm['Cluster'],
                          cmap='viridis', alpha=0.5, s=20)
axes[0].set_title('Customer Clusters: Frequency vs Monetary', fontsize=12, fontweight='bold')
axes[0].set_xlabel('Frequency (# of orders)')
axes[0].set_ylabel('Monetary Value ($)')
axes[0].set_xlim(0, rfm['Frequency'].quantile(0.95))
axes[0].set_ylim(0, rfm['Monetary'].quantile(0.95))
plt.colorbar(scatter, ax=axes[0], label='Cluster')

# Box plot: Monetary by Cluster
rfm.boxplot(column='Monetary', by='Cluster_Name', ax=axes[1])
axes[1].set_title('Monetary Value Distribution by Cluster', fontsize=12, fontweight='bold')
axes[1].set_xlabel('Cluster')
axes[1].set_ylabel('Monetary Value ($)')
axes[1].set_ylim(0, rfm['Monetary'].quantile(0.90))
plt.suptitle('')

plt.tight_layout()
plt.savefig('kmeans_clusters.png', dpi=150, bbox_inches='tight')
plt.show()

"""## 6. Time Series Forecasting (Monthly Revenue)"""

# Prepare monthly revenue data
monthly_data = data.groupby(data['InvoiceDate'].dt.to_period('M'))['Revenue'].sum().reset_index()
monthly_data.columns = ['Month', 'Revenue']
monthly_data['Month'] = monthly_data['Month'].dt.to_timestamp()
monthly_data = monthly_data.set_index('Month')

print('Monthly Revenue Data:')
monthly_data

# Simple Moving Average Forecast
monthly_data['SMA_3'] = monthly_data['Revenue'].rolling(window=3).mean()

# Exponential Moving Average
monthly_data['EMA_3'] = monthly_data['Revenue'].ewm(span=3, adjust=False).mean()

# Calculate growth rate
monthly_data['Growth_Rate'] = monthly_data['Revenue'].pct_change() * 100

# Plot
fig, axes = plt.subplots(2, 1, figsize=(12, 10))

# Revenue with forecasts
axes[0].plot(monthly_data.index, monthly_data['Revenue'], marker='o', label='Actual', linewidth=2)
axes[0].plot(monthly_data.index, monthly_data['SMA_3'], label='3-Month SMA', linestyle='--', linewidth=2)
axes[0].plot(monthly_data.index, monthly_data['EMA_3'], label='3-Month EMA', linestyle=':', linewidth=2)
axes[0].set_title('Monthly Revenue with Moving Averages', fontsize=14, fontweight='bold')
axes[0].set_xlabel('Month')
axes[0].set_ylabel('Revenue ($)')
axes[0].legend()
axes[0].yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

# Growth rate
colors = ['green' if x > 0 else 'red' for x in monthly_data['Growth_Rate'].fillna(0)]
axes[1].bar(monthly_data.index, monthly_data['Growth_Rate'].fillna(0), color=colors, alpha=0.7)
axes[1].axhline(y=0, color='black', linestyle='-', linewidth=0.5)
axes[1].set_title('Month-over-Month Revenue Growth Rate', fontsize=14, fontweight='bold')
axes[1].set_xlabel('Month')
axes[1].set_ylabel('Growth Rate (%)')

plt.tight_layout()
plt.savefig('c', dpi=150, bbox_inches='tight')
plt.show()

print('\n=== Forecast Insights ===')
print(f"Average Monthly Revenue: ${monthly_data['Revenue'].mean():,.2f}")
print(f"Average Growth Rate: {monthly_data['Growth_Rate'].mean():.1f}%")
print(f"November shows strong seasonal spike - prepare inventory accordingly")

"""## 7. Key Findings & Recommendations"""

# Summary Dashboard
print('='*60)
print('         E-COMMERCE ANALYTICS SUMMARY REPORT')
print('='*60)

print('\nðŸ“Š BUSINESS METRICS')
print('-'*40)
print(f"Total Revenue:          ${data['Revenue'].sum():>15,.2f}")
print(f"Total Transactions:     {data['InvoiceNo'].nunique():>15,}")
print(f"Total Customers:        {data['CustomerID'].nunique():>15,}")
print(f"Total Products:         {data['StockCode'].nunique():>15,}")
print(f"Avg Order Value:        ${data.groupby('InvoiceNo')['Revenue'].sum().mean():>15,.2f}")
print(f"Avg Customer LTV:       ${rfm['Monetary'].mean():>15,.2f}")

print('\nðŸ‘¥ CUSTOMER SEGMENTS')
print('-'*40)
for segment in ['Champions', 'Loyal Customers', 'At Risk', 'Lost']:
    if segment in segment_summary.index:
        row = segment_summary.loc[segment]
        print(f"{segment:20s}: {row['Count']:>5.0f} customers ({row['Pct_Revenue']:.1f}% of revenue)")

print('\nðŸ“ˆ KEY INSIGHTS')
print('-'*40)
print('1. Peak sales month: November (holiday season)')
print('2. Best sales days: Tuesday-Thursday')
print('3. Peak hours: 10 AM - 3 PM')
print(f'4. UK dominates revenue ({uk_pct:.1f}%), Germany & France lead international')
print('5. Champions segment drives disproportionate revenue')

print('\nðŸ’¡ RECOMMENDATIONS')
print('-'*40)
print('1. Launch re-engagement campaign for "At Risk" customers')
print('2. Create VIP rewards program for Champions')
print('3. Increase inventory before November peak')
print('4. Schedule marketing emails for 10 AM - 12 PM')
print('5. Expand marketing in Germany, France, Netherlands')
print('6. Consider weekend promotions (currently low Saturday sales)')

print('\n' + '='*60)

# Export customer segments for CRM
rfm_export = rfm[['CustomerID', 'Recency', 'Frequency', 'Monetary', 'Segment', 'Cluster_Name']]
rfm_export.to_csv('customer_segments.csv', index=False)
print('Customer segments exported to: customer_segments.csv')

# Export monthly summary for dashboard
monthly_data.to_csv('monthly_revenue.csv')
print('Monthly revenue data exported to: monthly_revenue.csv')

"""---

## Project Summary

This analysis provided actionable insights for an e-commerce business:

**Technical Skills Demonstrated:**
- Data cleaning and preprocessing (Pandas)
- Exploratory data analysis and visualization (Matplotlib, Seaborn)
- Customer segmentation using RFM analysis
- Machine learning clustering (K-Means)
- Time series analysis and forecasting
- Business insights and recommendations

**Business Value Delivered:**
- Identified high-value customer segments for targeted marketing
- Discovered revenue patterns for inventory optimization
- Provided actionable recommendations for customer retention

---

**Author:** Seun Alo  
**LinkedIn:** [linkedin.com/in/seunalo](https://linkedin.com/in/seunalo)  
**GitHub:** [github.com/seunalo](https://github.com/seunalo)
"""